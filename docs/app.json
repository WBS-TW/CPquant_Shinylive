[{"name":"app.R","content":"# This version was copied 20250910\r\n# Uses Shinylive to deploy static web app\r\n# see: https://hbctraining.github.io/Training-modules/RShiny/lessons/shinylive.html\r\n\r\nlibrary(shiny)\r\nlibrary(htmlwidgets)\r\nlibrary(ggplot2)\r\nlibrary(readxl)\r\nlibrary(stringr)\r\nlibrary(nnls)\r\nlibrary(dplyr)\r\nlibrary(tibble)\r\nlibrary(tidyr)\r\nlibrary(DT)\r\nlibrary(plotly)\r\nlibrary(purrr)\r\nlibrary(markdown)\r\nlibrary(openxlsx)\r\n\r\n# Various utilities and helper functions for CPquant\r\n\r\n\r\n#########################################################################################################\r\n#------------------------------------------ CPquant utils ------------------------------------------#\r\n#########################################################################################################\r\n\r\n\r\n### Function to perform deconvolution on a single data frame ###\r\nperform_deconvolution <- function(df, combined_standard, CPs_standards_sum_RF) {\r\n\r\n    df_matrix <- as.matrix(df)\r\n\r\n    print(paste(\"df_matrix dimensions:\", dim(df_matrix)))\r\n    print(paste(\"combined_standard dimensions:\", dim(combined_standard)))\r\n\r\n    if (nrow(combined_standard) != nrow(df_matrix)) {\r\n        stop(\"Dimensions of combined_standard and df are incompatible.\")\r\n    }\r\n\r\n    # Reshape df_matrix if it has only one column or extract the first column if it has multiple\r\n    if (ncol(df_matrix) == 1) {\r\n        df_vector <- as.vector(df_matrix)\r\n    } else {\r\n        df_vector <- as.vector(df_matrix[\"Relative_Area\"])  # Extract the first column for nnls\r\n    }\r\n\r\n    # Check for NA/NaN/Inf values in df_vector and combined_standard\r\n    if (any(is.na(df_vector)) || any(is.nan(df_vector)) || any(is.infinite(df_vector))) {\r\n        stop(\"df_vector contains NA/NaN/Inf values.\")\r\n    }\r\n\r\n    if (any(is.na(combined_standard)) || any(is.nan(combined_standard)) || any(is.infinite(combined_standard))) {\r\n        stop(\"combined_standard contains NA/NaN/Inf values.\")\r\n    }\r\n\r\n    # Perform nnls\r\n    # combined_standard is response factor and df_vector is Relative_Area\r\n    deconv <- nnls::nnls(combined_standard, df_vector)\r\n\r\n    # Extract deconvolution results\r\n    deconv_coef <- deconv$x\r\n\r\n\r\n    #Normalize the coefficients so they sum to 1\r\n    if (sum(deconv_coef) > 0) {\r\n        deconv_coef <- deconv_coef / sum(deconv_coef)\r\n    }else(deconv_coef <- 0)\r\n\r\n    # Calculate deconvolved values (which is the response factor) using matrix multiplication\r\n    deconv_resolved <- combined_standard %*% deconv_coef\r\n\r\n    # Calculate the sum of RF*frac\r\n    sum_deconv_RF <- as.matrix(CPs_standards_sum_RF) %*% deconv_coef\r\n\r\n\r\n\r\n\r\n\r\n    # Calculate the goodness of fit by coefficient of determination (R2)\r\n    # Calculate the total sum of squares (SST)\r\n    sst <- sum((df_vector - mean(df_vector))^2)\r\n    # Calculate the residual sum of squares (SSR)\r\n    ssr <- sum((df_vector - deconv_resolved/sum(deconv_resolved))^2)\r\n\r\n    # Calculate R-squared coefficient of determination\r\n    deconv_rsquared <- 1 - (ssr / sst)\r\n\r\n    # Calculate Mean Squared Error (MSE)\r\n    mse <- mean((df_vector - deconv_resolved/sum(deconv_resolved))^2)\r\n\r\n    # Calculate Root Mean Squared Error (RMSE)\r\n    rmse <- sqrt(mse)\r\n\r\n    #Chiq-square test: ensure that values are positive for chi-square test\r\n    # if (any(deconv_resolved < 0) || any(df_vector < 0)) {\r\n    #     warning(\"Non-positive values found, skipping chi-square test\")\r\n    #     chisq_result <- NULL\r\n    # } else {\r\n    #     #adding a very small constant to avoid 0 values\r\n    #     observed_corr <- df_vector + 1E-12\r\n    #     predicted_corr <- deconv_resolved + 1E-12\r\n    #     chisq_result <- chisq.test(x= observed_corr, p = predicted_corr/sum(predicted_corr), rescale.p = TRUE)\r\n    # }\r\n\r\n\r\n    # Kolmogorov-Smirnov Test\r\n    #ks_result <- ks.test(deconv_resolved, df_vector)\r\n\r\n\r\n\r\n    #combine results for output\r\n    combined_standard_names <- colnames(combined_standard)\r\n\r\n    names(deconv_coef) <- combined_standard_names\r\n\r\n\r\n    return(list(\r\n        sum_deconv_RF = sum_deconv_RF,\r\n        deconv_coef = deconv_coef,\r\n        deconv_resolved = deconv_resolved,\r\n        deconv_rsquared = deconv_rsquared\r\n        #chisq_result = chisq_result\r\n    ))\r\n}\r\n\r\n\r\n\r\n\r\n################################################################################\r\n\r\n## CPquant UI Components ##\r\n###########################\r\n\r\ndefineVariablesUI <- function(Skyline_output){\r\n    ###START: Define UI components\r\n\r\n    # Create the UI components\r\n    shiny::fluidRow(\r\n        shiny::column(\r\n            6,\r\n            shiny::selectInput(\r\n                inputId = \"removeSamples\", #select if some samples will be removed from quantification\r\n                label = 'Remove samples from quantification?',\r\n                choices = unique(Skyline_output$Replicate_Name),\r\n                selected = NULL,\r\n                multiple = TRUE\r\n            )\r\n        ),\r\n\r\n        shiny::tags$br(), shiny::tags$br(), shiny::tags$br(), shiny::tags$br(),\r\n        shiny::column(\r\n            6,\r\n            shiny::sliderInput(\r\n                inputId = \"removeRsquared\", #keep only Molecule from standard calibration curves above this rsquared, zero means keep everything\r\n                label = 'Keep the the calibration curves above this rsquared (0 means keep everything)',\r\n                min = 0,\r\n                max = 1,\r\n                value = 0.70,\r\n                step = 0.05\r\n            )\r\n            # shiny::column(\r\n            #     6,\r\n            #     shiny::checkboxInput(\r\n            #           inputId = \"zerointercept\", #force y-intercept through zero\r\n            #           label = \"Set intercept to zero\",\r\n            #           value = FALSE\r\n            #     )\r\n        )\r\n    )\r\n}\r\n### END FUNCTION\r\n\r\n\r\ndefineRecoveryUI <- function(Skyline_output){\r\n    ###START: Define UI components\r\n\r\n    # Create the UI components\r\n    shiny::fluidRow(\r\n        shiny::column(\r\n            6,\r\n            shiny::selectInput(\r\n                inputId = \"chooseRS\", #select which will be the RS\r\n                label = 'Choose RS',\r\n                choices = unique(Skyline_output$Molecule[Skyline_output$Molecule_List == \"RS\"]),\r\n                selected = NULL,\r\n                multiple = FALSE\r\n            )\r\n        ))\r\n}\r\n\r\n\r\n## CPquant plots ##\r\n###########################\r\nplot_skyline_output <- function(Skyline_output){\r\n\r\n    Skyline_output |>\r\n        dplyr::filter(Isotope_Label_Type == \"Quan\") |>\r\n        dplyr::mutate(OrderedMolecule = factor(Molecule, levels = unique(Molecule[order(C_number, Cl_number)]))) |>  # Create a composite ordering factor\r\n        plotly::plot_ly(\r\n            x = ~ OrderedMolecule,\r\n            y = ~ Area,\r\n            color = ~ Sample_Type,\r\n            type = \"box\",\r\n            text = ~paste(\r\n                \"Homologue: \", PCA,\r\n                \"<br>Sample: \", Replicate_Name,\r\n                \"<br>Area:\", round(Area, 2)\r\n            ),\r\n            hoverinfo = \"text\"\r\n        ) |>\r\n        plotly::layout(xaxis = list(title = 'Molecule'),\r\n                       yaxis = list(title = 'Area'))\r\n}\r\n\r\n#############################################################################\r\n\r\nplot_calibration_curves <- function(CPs_standards, quantUnit) {\r\n    # Unnest the data first\r\n    CPs_standards_unnested <- CPs_standards |>\r\n        dplyr::filter(RF > 0) |>\r\n        tidyr::unnest(data) |>\r\n        dplyr::mutate(Molecule = factor(Molecule,\r\n                                        levels = unique(Molecule[order(C_number, Cl_number)])))\r\n\r\n    # Get unique Quantification Groups\r\n    groups <- unique(CPs_standards_unnested$Quantification_Group)\r\n\r\n    # Create a list to store individual plots\r\n    plot_list <- list()\r\n\r\n    # Create individual plots for each group\r\n    for(i in seq_along(groups)) {\r\n        group_data <- CPs_standards_unnested |>\r\n            dplyr::filter(Quantification_Group == groups[i])\r\n\r\n        plot_list[[i]] <- plotly::plot_ly() |>\r\n            plotly::add_trace(\r\n                data = group_data,\r\n                x = ~Analyte_Concentration,\r\n                y = ~Area,\r\n                color = ~PCA,\r\n                type = 'scatter',\r\n                mode = 'markers',\r\n                legendgroup = ~Molecule_List,\r\n                legendgrouptitle = list(text = ~Molecule_List),\r\n                showlegend = FALSE,\r\n                name = ~paste(PCA, \"(points)\"),\r\n                text = ~paste(\r\n                    \"Molecule:\", Molecule,\r\n                    \"<br>Area:\", round(Area, 2),\r\n                    \"<br>Concentration:\", round(Analyte_Concentration, 2),\r\n                    \"<br>R2:\", round(rsquared, 3)\r\n                ),\r\n                hoverinfo = 'text'\r\n            ) |>\r\n            plotly::add_trace(\r\n                data = group_data,\r\n                x = ~Analyte_Concentration,\r\n                y = ~RF * Analyte_Concentration + intercept,\r\n                color = ~PCA,\r\n                type = 'scatter',\r\n                mode = 'lines',\r\n                legendgroup = ~Molecule_List,\r\n                name = ~PCA,\r\n                hoverinfo = 'none'\r\n            )\r\n    }\r\n\r\n    # Calculate layout\r\n    subplot_cols <- min(length(groups), 2)  # Maximum 2 columns\r\n    subplot_rows <- ceiling(length(groups) / subplot_cols)\r\n\r\n    # Create annotations for titles\r\n    annotations <- list()\r\n    for(i in seq_along(groups)) {\r\n        row <- ceiling(i/subplot_cols)\r\n        col <- if(i %% subplot_cols == 0) subplot_cols else i %% subplot_cols\r\n\r\n        annotations[[i]] <- list(\r\n            text = groups[i],\r\n            font = list(size = 14),\r\n            xref = \"paper\",\r\n            yref = \"paper\",\r\n            x = (col - 0.5)/subplot_cols,\r\n            y = 1 - (row - 1)/subplot_rows,\r\n            xanchor = \"center\",\r\n            yanchor = \"bottom\",\r\n            showarrow = FALSE\r\n        )\r\n    }\r\n\r\n    # Combine plots using subplot\r\n    final_plot <- plotly::subplot(\r\n        plot_list,\r\n        nrows = subplot_rows,\r\n        shareX = FALSE,\r\n        #shareY = TRUE,\r\n        shareY = FALSE,\r\n        margin = 0.1\r\n    ) |>\r\n        plotly::layout(\r\n            height = 400 * subplot_rows,\r\n            showlegend = TRUE,\r\n            annotations = annotations,\r\n            margin = list(t = 50, b = 50, l = 50, r = 50),\r\n            legend = list(\r\n                groupclick = \"togglegroup\",  # Changed from \"toggleitem\" to \"togglegroup\"\r\n                tracegroupgap = 10,\r\n                itemsizing = \"constant\"\r\n            ),\r\n            xaxis = list(title = paste0(\"Analyte Concentration/Amount (\", quantUnit, \")\"))  # Use the reactive value for x-axis label\r\n        )\r\n\r\n    return(final_plot)\r\n}\r\n\r\n#############################################################################\r\n\r\nplot_quanqualratio <- function(Skyline_output_filt) {\r\n\r\n    Skyline_output_filt |>\r\n        dplyr::group_by(Replicate_Name, Molecule) |>\r\n        dplyr::mutate(Quan_Area = ifelse(Isotope_Label_Type == \"Quan\", Area, NA)) |>\r\n        tidyr::fill(Quan_Area, .direction = \"downup\") |>\r\n        dplyr::mutate(QuanMZ = ifelse(Isotope_Label_Type == \"Quan\", Chromatogram_Precursor_MZ, NA)) |>\r\n        tidyr::fill(QuanMZ, .direction = \"downup\") |>\r\n        dplyr::mutate(QuanQualRatio = ifelse(Isotope_Label_Type == \"Qual\", Quan_Area/Area, 1)) |>\r\n        tidyr::replace_na(list(QuanQualRatio = 0)) |>\r\n        dplyr::mutate(QuanQualMZ = paste0(QuanMZ,\"/\",Chromatogram_Precursor_MZ)) |>\r\n        dplyr::ungroup() |>\r\n        dplyr::select(Replicate_Name, Sample_Type, Molecule_List, Molecule, QuanQualMZ, QuanQualRatio) |>\r\n        plotly::plot_ly(x = ~Replicate_Name, y = ~QuanQualRatio, type = 'violin', color = ~Sample_Type,\r\n                        text = ~paste(\"Sample: \", Replicate_Name,\r\n                                      \"<br>Molecule List: \", Molecule_List,\r\n                                      \"<br>Molecule: \", Molecule,\r\n                                      \"<br>Quan/Qual MZ: \", QuanQualMZ,\r\n                                      \"<br>Ratio: \", round(QuanQualRatio, 2)),\r\n                        hoverinfo = \"text\") |>\r\n        plotly::layout(title = 'Quan-to-Qual Ratio',\r\n                       xaxis = list(title = 'Replicate Name'),\r\n                       yaxis = list(title = 'Quan-to-Qual Ratio'))\r\n}\r\n\r\n##############################################################################\r\n\r\nplot_meas_vs_theor_ratio <- function(Skyline_output_filt) {\r\n\r\n    Skyline_output_filt |>\r\n        dplyr::group_by(Replicate_Name, Molecule) |>\r\n        dplyr::mutate(Quan_Area = ifelse(Isotope_Label_Type == \"Quan\", Area, NA)) |>\r\n        tidyr::fill(Quan_Area, .direction = \"downup\") |>\r\n        dplyr::mutate(QuanMZ = ifelse(Isotope_Label_Type == \"Quan\", Chromatogram_Precursor_MZ, NA)) |>\r\n        tidyr::fill(QuanMZ, .direction = \"downup\") |>\r\n        dplyr::mutate(QuanQualRatio = ifelse(Isotope_Label_Type == \"Qual\", Quan_Area/Area, 1)) |>\r\n        tidyr::replace_na(list(QuanQualRatio = 0)) |>\r\n        dplyr::mutate(QuanQualMZ = paste0(QuanMZ,\"/\",Chromatogram_Precursor_MZ)) |>\r\n\r\n        dplyr::mutate(Quan_Rel_Ab = ifelse(Isotope_Label_Type == \"Quan\", Rel_Ab, NA)) |>\r\n        tidyr::fill(Quan_Rel_Ab, .direction = \"downup\") |>\r\n        dplyr::mutate(QuanQual_Rel_Ab_Ratio = ifelse(Isotope_Label_Type == \"Qual\", Quan_Rel_Ab/Rel_Ab, 1)) |>\r\n        tidyr::replace_na(list(QuanQual_Rel_Ab_Ratio = 0)) |>\r\n        dplyr::ungroup() |>\r\n        dplyr::mutate(MeasVSTheo = QuanQualRatio/QuanQual_Rel_Ab_Ratio) |>\r\n        dplyr::mutate(Is_Outlier = MeasVSTheo > 3 | MeasVSTheo < 0.3) |>\r\n        dplyr::mutate(Is_Outlier = factor(Is_Outlier, levels = c(FALSE, TRUE), labels = c(\"Within Limit\", \"Outlier\"))) |>\r\n        dplyr::select(Replicate_Name, Sample_Type, Molecule_List, Molecule, QuanQualMZ, QuanQualRatio, QuanQual_Rel_Ab_Ratio, MeasVSTheo, Is_Outlier) |>\r\n        plotly::plot_ly(x = ~Replicate_Name, y = ~MeasVSTheo,\r\n                        type = 'scatter', mode = 'markers',\r\n                        color = ~Is_Outlier,\r\n                        colors = c('blue', 'red'),\r\n                        text = ~paste(\"Replicate:\", Replicate_Name,\r\n                                      \"<br>Homologue Group: \", Molecule,\r\n                                      \"<br>Measured against Theoretical Ratio:\", round(MeasVSTheo, 1)),\r\n                        marker = list(size = 10)) |>\r\n        layout(title = \"Measured/Theoretical ratio >3 or <0.3 are marked in red (ratio of 1 means perfect match\",\r\n               xaxis = list(title = \"Sample Name\"),\r\n               yaxis = list(title = \"MeasVSTheo\"))\r\n\r\n}\r\n\r\n\r\n##############################################################################\r\n\r\nplot_sample_contribution <- function(deconvolution) {\r\n\r\n    # How much contribution of each sample to the final deconvoluted homologue group pattern\r\n    plot_data <- deconvolution |>\r\n        tidyr::unnest(deconv_coef) |>\r\n        tidyr::unnest_longer(c(deconv_coef, Batch_Name)) |>\r\n        dplyr::select(Replicate_Name, Batch_Name, deconv_coef)\r\n\r\n    # Create the plotly stacked bar plot\r\n    plotly::plot_ly(plot_data,\r\n                    x = ~Replicate_Name,\r\n                    y = ~deconv_coef,\r\n                    type = \"bar\",\r\n                    color = ~Batch_Name,\r\n                    colors = \"Spectral\") |>\r\n        plotly::layout(\r\n            title = list(\r\n                text = \"Contributions from standards to deconvoluted homologue pattern\",\r\n                x = 0.5,  # Center the title\r\n                y = 0.95  # Position slightly down from top\r\n            ),\r\n            barmode = \"stack\",\r\n            xaxis = list(title = \"Replicate Name\"),\r\n            yaxis = list(title = \"Relative Contribution\",\r\n                         tickformat = \".2%\"),\r\n            showlegend = TRUE,\r\n            legend = list(title = list(text = \"Batch Name\"))\r\n        )\r\n}\r\n\r\n#############################################################################\r\n\r\nplot_homologue_group_pattern_comparison <- function(Sample_distribution, input_selectedSamples){\r\n\r\n    # Filter data for selected samples and reshape data\r\n    selected_samples <- Sample_distribution |>\r\n        dplyr::filter(Replicate_Name %in% input_selectedSamples) |>\r\n        dplyr::mutate(Molecule = factor(Molecule, levels = unique(Molecule[order(C_number, Cl_number)])))\r\n\r\n    # Get unique homologue groups for consistent coloring\r\n    homologue_groups <- unique(selected_samples$C_homologue)\r\n\r\n    # Create a list of plots, one for each Replicate_Name\r\n    plot_list <- selected_samples |>\r\n        split(selected_samples$Replicate_Name) |>\r\n        map(function(df) {\r\n            # Create base plot\r\n            p <- plotly::plot_ly()\r\n\r\n            # Add bars for each homologue group\r\n            for(hg in homologue_groups) {\r\n                df_filtered <- df[df$C_homologue == hg,]\r\n                p <- p |>\r\n                    plotly::add_trace(\r\n                        data = df_filtered,\r\n                        x = ~Molecule,\r\n                        y = ~Relative_Area,\r\n                        name = hg,\r\n                        legendgroup = hg,\r\n                        showlegend = (df_filtered$Replicate_Name[1] == input_selectedSamples[1]),\r\n                        type = 'bar',\r\n                        opacity = 1\r\n                    )\r\n            }\r\n\r\n            # Add the black line for resolved_distribution\r\n            p <- p |>\r\n                plotly::add_trace(\r\n                    data = df,\r\n                    x = ~Molecule,\r\n                    y = ~resolved_distribution,\r\n                    name = \"Deconvoluted Distribution\",\r\n                    legendgroup = \"DeconvDistr\",\r\n                    showlegend = (df$Replicate_Name[1] == input_selectedSamples[1]),\r\n                    type = 'scatter',\r\n                    mode = 'lines+markers',\r\n                    line = list(color = 'black'),\r\n                    marker = list(color = 'black', size = 6),\r\n                    opacity = 0.7\r\n                )\r\n\r\n            # Add layout\r\n            p <- p |>\r\n                plotly::layout(\r\n                    xaxis = list(\r\n                        title = \"Homologue\",\r\n                        tickangle = 45\r\n                    ),\r\n                    yaxis = list(title = \"Value\"),\r\n                    barmode = 'group',\r\n                    annotations = list(\r\n                        x = 0.5,\r\n                        y = 1.1,\r\n                        text = unique(df$Replicate_Name),\r\n                        xref = 'paper',\r\n                        yref = 'paper',\r\n                        showarrow = FALSE\r\n                    )\r\n                )\r\n\r\n            return(p)\r\n        })\r\n\r\n    # Combine the plots using subplot\r\n    plotly::subplot(plot_list,\r\n                    nrows = ceiling(length(plot_list)/2),\r\n                    shareX = TRUE,\r\n                    shareY = TRUE) |>\r\n        plotly::layout(\r\n            #title = \"Sample Comparison\",\r\n            showlegend = TRUE,\r\n            hovermode = 'closest',\r\n            hoverlabel = list(bgcolor = \"white\"),\r\n            barmode = 'group'\r\n        ) |>\r\n        plotly::config(displayModeBar = TRUE) |>\r\n        htmlwidgets::onRender(\"\r\n                function(el) {\r\n                    var plotDiv = document.getElementById(el.id);\r\n                    plotDiv.on('plotly_legendclick', function(data) {\r\n                        Plotly.restyle(plotDiv, {\r\n                            visible: data.data[data.curveNumber].visible === 'legendonly' ? true : 'legendonly'\r\n                        }, data.fullData.map((trace, i) => i).filter(i =>\r\n                            data.fullData[i].legendgroup === data.fullData[data.curveNumber].legendgroup\r\n                        ));\r\n                        return false;\r\n                    });\r\n                }\r\n            \")\r\n}\r\n\r\n#############################################################################\r\n\r\noptions(shiny.maxRequestSize = 500 * 1024^2)\r\n\r\n\r\nui <- shiny::navbarPage(\"CPquant\",\r\n                        shiny::tabPanel(\"Quantification Inputs\",\r\n                                        shiny::fluidPage(shiny::sidebarLayout(\r\n                                            shiny::sidebarPanel(\r\n                                                width = 3,\r\n                                                shiny::fileInput(\"fileInput\", \"Import excel file from Skyline\",\r\n                                                                 accept = c('xlsx')),\r\n                                                shiny::textInput(\"quantificationUnit\", \"(Optional) Concentration unit:\"),\r\n                                                shiny::radioButtons(\"blankSubtraction\",\r\n                                                                    label = \"Subtraction with blank?\",\r\n                                                                    choices = c(\"Yes, by avg area of blanks\", \"No\"), selected = \"No\"),\r\n                                                shiny::radioButtons(\"correctWithRS\", label = \"Correct with RS area?\",\r\n                                                                    choices = c(\"Yes\", \"No\"), selected = \"No\"),\r\n                                                shiny::uiOutput(\"recoveryUI\"), # render UI if correctwithRS == \"Yes\"\r\n                                                shiny::radioButtons(\"calculateRecovery\",\r\n                                                                    label = \"Calculate recovery? (req QC samples)\",\r\n                                                                    choices = c(\"Yes\", \"No\"), selected = \"No\"),\r\n                                                shiny::radioButtons(\"calculateMDL\",\r\n                                                                    label = \"Calculate MDL? (req blank samples)\",\r\n                                                                    choices = c(\"Yes\", \"No\"), selected = \"No\"),\r\n                                                shiny::radioButtons(\"standardTypes\", label = \"Types of standards\",\r\n                                                                    choices = c(\"Group Mixtures\"), selected = \"Group Mixtures\"), #work for both single chain and multiple chain mixtures\r\n                                                shiny::tags$div(\r\n                                                    title = \"Wait until import file is fully loaded before pressing!\",\r\n                                                    shiny::actionButton('go', 'Proceed', width = \"100%\")\r\n                                                ),\r\n                                                shiny::uiOutput(\"defineVariables\")\r\n                                            ),\r\n                                            shiny::mainPanel(\r\n                                                width = 9,\r\n                                                plotly::plotlyOutput(\"plot_Skyline_output\"),\r\n                                                DT::DTOutput(\"table_Skyline_output\")\r\n\r\n                                            )\r\n                                        )\r\n                                        )),\r\n                        shiny::tabPanel(\r\n                            \"Input summary\",\r\n                            shiny::sidebarPanel(\r\n                                width = 2, # max 12\r\n                                shiny::radioButtons(\"navSummary\", \"Choose tab:\",\r\n                                                    choices = c(\"Std Calibration Curves\",\r\n                                                                \"Removed from Calibration\",\r\n                                                                \"Quan to Qual ratio\",\r\n                                                                \"Measured vs Theor Quan/Qual ratio\"),\r\n                                                    selected = \"Std Calibration Curves\")\r\n                            ),\r\n                            shiny::mainPanel(\r\n                                width = 10,\r\n                                shiny::conditionalPanel(\r\n                                    condition = \"input.navSummary == 'Std Calibration Curves'\",\r\n                                    tags$h3(\"Standard calibration curves\"),\r\n                                    plotly::plotlyOutput(\"CalibrationCurves\")\r\n                                ),\r\n                                shiny::conditionalPanel(\r\n                                    condition = \"input.navSummary == 'Removed from Calibration'\",\r\n                                    tags$h3(\"Calibration series removed from quantification\"),\r\n                                    DT::DTOutput(\"CalibrationRemoved\")\r\n                                ),\r\n                                shiny::conditionalPanel(\r\n                                    condition = \"input.navSummary == 'Quan to Qual ratio'\",\r\n                                    tags$h3(\"Violin plots of Quant/Qual ions\"),\r\n                                    plotly::plotlyOutput(\"RatioQuantToQual\", height = \"80vh\", width = \"100%\")\r\n                                ),\r\n                                shiny::conditionalPanel(\r\n                                    condition = \"input.navSummary == 'Measured vs Theor Quan/Qual ratio'\",\r\n                                    tags$h3(\"Measured divided by Theoretical Quant/Qual ratios\"),\r\n                                    plotly::plotlyOutput(\"MeasVSTheor\", height = \"80vh\", width = \"100%\")\r\n                                )\r\n                            )\r\n                        ),\r\n\r\n                        shiny::tabPanel(\r\n                            \"Quantification summary\",\r\n                            shiny::fluidPage(\r\n                                downloadButton(\"downloadResults\", \"Export all results to Excel\"),\r\n                                shiny::tags$br(), shiny::tags$br(),\r\n                                DT::DTOutput(\"quantTable\"),\r\n                                shiny::tags$br(),\r\n                                plotly::plotlyOutput(\"sampleContributionPlot\")\r\n                            )\r\n                        ),\r\n                        shiny::tabPanel(\r\n                            \"Homologue Group Patterns\",\r\n                            fluidRow(\r\n                                column(\r\n                                    width = 2,\r\n                                    shiny::radioButtons(\"plotHomologueGroups\", \"Choose tab:\",\r\n                                                        choices = c(\"All Samples Overview\", \"Samples Overlay\", \"Samples Panels\"),\r\n                                                        selected = \"All Samples Overview\"),\r\n                                    shiny::conditionalPanel(\r\n                                        condition = \"input.plotHomologueGroups == 'Samples Overlay'\",\r\n                                        shiny::uiOutput(\"sampleSelectionUIOverlay\")\r\n                                    ),\r\n                                    shiny::conditionalPanel(\r\n                                        condition = \"input.plotHomologueGroups == 'Samples Panels'\",\r\n                                        shiny::uiOutput(\"sampleSelectionUIComparisons\")\r\n                                    ),\r\n                                    shiny::tags$div(\r\n                                        title = \"WAIT after pressing..Might take some time before plot shows!\",\r\n                                        shiny::actionButton('go2', 'Plot', width = \"100%\")\r\n                                    )\r\n                                ),\r\n                                column(\r\n                                    width = 10,\r\n                                    # Add a div with margin/padding for spacing\r\n                                    shiny::tags$div(\r\n                                        style = \"margin-top: 20px;\", # This adds space at the top\r\n\r\n                                        shiny::conditionalPanel(\r\n                                            condition = \"input.plotHomologueGroups == 'All Samples Overview'\",\r\n                                            shiny::plotOutput(\"plotHomologuePatternStatic\", height = \"80vh\", width = \"100%\")\r\n                                        ),\r\n                                        shiny::conditionalPanel(\r\n                                            condition = \"input.plotHomologueGroups == 'Samples Overlay'\",\r\n                                            plotly::plotlyOutput(\"plotHomologuePatternOverlay\", height = \"80vh\", width = \"100%\")\r\n                                        ),\r\n                                        shiny::conditionalPanel(\r\n                                            condition = \"input.plotHomologueGroups == 'Samples Panels'\",\r\n                                            plotly::plotlyOutput(\"plotHomologuePatternComparisons\", height = \"80vh\", width = \"100%\")\r\n                                        )\r\n                                    )\r\n                                )\r\n                            )\r\n                        ),\r\n                        shiny::tabPanel(\r\n                            \"QA/QC\",\r\n                            shiny::mainPanel(\r\n                                DT::DTOutput(\"table_recovery\"),   # First table output (Skyline recovery data)\r\n                                br(),                     # Optional line break to add space between the tables\r\n                                DT::DTOutput(\"table_MDL\")       # Second table output (LOD table)\r\n                            )\r\n                        ),\r\n                        shiny::tabPanel(\r\n                            \"Instructions\",\r\n                            shiny::sidebarLayout(\r\n                                shiny::sidebarPanel(shiny::h3(\"Manual\"),\r\n                                                    width = 3),\r\n                                shiny::mainPanel(\r\n                                    shiny::includeMarkdown(system.file(\"instructions_CPquant.md\", package = \"CPxplorer\"))\r\n                                )\r\n                            )\r\n                        )\r\n\r\n)\r\n\r\n################################################################################\r\nserver <- function(input, output, session) {\r\n\r\n    # define RS\r\n    output$recoveryUI <- shiny::renderUI({\r\n        if(input$correctWithRS == \"Yes\") {\r\n            defineRecoveryUI(Skyline_output()) }\r\n    })\r\n    #chooseRS <- shiny::reactive(as.character(input$chooseRS))\r\n\r\n    # Create a reactive object that depends on the quantificationUnit input\r\n    quantUnit <- reactive({\r\n        input$quantificationUnit\r\n    })\r\n\r\n    Skyline_output <- reactive({\r\n        req(input$fileInput) #requires that the input is available\r\n\r\n        # Create a Progress object\r\n        progress <- shiny::Progress$new()\r\n        on.exit(progress$close())\r\n\r\n        progress$set(message = \"WAIT! Loading data...\", value = 0)\r\n\r\n        # Read the Skyline output Excel file\r\n        progress$set(value = 0.3, detail = \"Reading Excel file\")\r\n        df <- readxl::read_excel(input$fileInput$datapath, guess_max = 5000, na = c(\"\", \"NA\", \"#N/A\", \"N/A\")) #outputs a tibble\r\n\r\n        progress$set(value = 0.6, detail = \"Processing data\")\r\n        # Tidy the input file\r\n        df <- df |>\r\n            dplyr::rename(Replicate_Name = tidyr::any_of(c(\"Replicate Name\", \"ReplicateName\"))) |>\r\n            dplyr::rename(Sample_Type = tidyr::any_of(c(\"Sample Type\", \"SampleType\"))) |>\r\n            dplyr::rename(Molecule_List = tidyr::any_of(c(\"Molecule List\", \"MoleculeList\"))) |>\r\n            dplyr::rename(Mass_Error_PPM = tidyr::any_of(c(\"Mass Error PPM\", \"MassErrorPPM\"))) |>\r\n            dplyr::rename(Isotope_Label_Type = tidyr::any_of(c(\"Isotope Label Type\", \"IsotopeLabelType\"))) |>\r\n            dplyr::rename(Chromatogram_Precursor_MZ = tidyr::any_of(c(\"Chromatogram Precursor M/Z\", \"ChromatogramPrecursorMz\"))) |>\r\n            dplyr::rename(Analyte_Concentration = tidyr::any_of(c(\"Analyte Concentration\", \"AnalyteConcentration\"))) |>\r\n            dplyr::rename(Batch_Name = tidyr::any_of(c(\"Batch Name\", \"BatchName\"))) |>\r\n            dplyr::mutate(Analyte_Concentration = as.numeric(Analyte_Concentration)) |>\r\n            dplyr::mutate(Area = as.numeric(Area)) |>\r\n            dplyr::mutate(Area = replace_na(Area, 0)) |>\r\n            dplyr::mutate(C_homologue = stringr::str_extract(Molecule, \"C\\\\d+\"),\r\n                          Cl_homologue = stringr::str_extract(Molecule, \"Cl\\\\d+\"),\r\n                          C_number = as.numeric(stringr::str_extract(C_homologue, \"\\\\d+\")),\r\n                          Cl_number = as.numeric(stringr::str_extract(Cl_homologue, \"\\\\d+\")),\r\n                          PCA = stringr::str_c(C_homologue, Cl_homologue, sep = \"\")) |>\r\n            dplyr::rename(Transition_Note = `Transition Note`) |>\r\n            dplyr::mutate(Rel_Ab = as.numeric(map_chr( # Extract relative abundance from second set of curly braces\r\n                Transition_Note, ~ {matches <- str_match_all(.x, \"\\\\{([^}]*)\\\\}\")[[1]]\r\n                if (nrow(matches) >= 2) matches[2, 2] else NA_character_\r\n                })))\r\n\r\n        progress$set(value = 0.8, detail = \"Applying corrections\")\r\n\r\n\r\n        # Normalize data based on 'Correct with RS' input\r\n        if (input$correctWithRS == \"Yes\" && any(df$Molecule_List == \"RS\")) {\r\n            # Only proceed with RS correction if chooseRS input is available\r\n            if (!is.null(input$chooseRS) && input$chooseRS != \"\") {\r\n                # Use input$chooseRS directly instead of the reactive\r\n                df <- df |>\r\n                    dplyr::group_by(Replicate_Name) |>\r\n                    dplyr::mutate(Area = Area / first(Area[Molecule == input$chooseRS &\r\n                                                               Molecule_List == \"RS\" &\r\n                                                               Isotope_Label_Type == \"Quan\"])) |>\r\n                    dplyr::ungroup()\r\n            }\r\n        }\r\n\r\n        # Calculate the average blank value\r\n        if (input$blankSubtraction == \"Yes, by avg area of blanks\"){\r\n            df_blank <- df |>\r\n                dplyr::filter(Sample_Type == \"Blank\") |>\r\n                dplyr::group_by(Molecule, Molecule_List, Isotope_Label_Type) |>\r\n                dplyr::summarize(AverageBlank = mean(Area, na.rm = TRUE)) |>\r\n                dplyr::ungroup() |>\r\n                dplyr::filter(!Molecule_List %in% c(\"IS\", \"RS\", \"VS\"))\r\n\r\n            df <- df |>\r\n                dplyr::full_join(df_blank) |>\r\n                dplyr::mutate(AverageBlank = tidyr::replace_na(AverageBlank, 0)) |>\r\n                dplyr::mutate(Area = dplyr::case_when(Sample_Type == \"Unknown\" ~ Area - AverageBlank, .default = Area)) |> #only blank subtraction of Unknown Sample Type\r\n                dplyr::mutate(Area = ifelse(Area <0, 0, Area)) #replace negative Area with 0 after blank subtraction\r\n        }\r\n\r\n\r\n        if (input$standardTypes == \"Group Mixtures\") {\r\n            df <- df |>\r\n                dplyr::mutate(Quantification_Group = stringr::str_extract(Batch_Name, \"^[^_]+\")) #extract the initial sequence of characters up to, but not including, the first underscore.\r\n        }\r\n\r\n        progress$set(value = 1, detail = \"Complete\")\r\n\r\n        return(df)\r\n    })\r\n\r\n    # defineVariablesUI in separate file UI_components.R\r\n    output$defineVariables <- shiny::renderUI({\r\n        defineVariablesUI(Skyline_output())\r\n    })\r\n\r\n\r\n    # Set reactive values from user input\r\n\r\n    removeRsquared <- shiny::eventReactive(input$go, {as.numeric(input$removeRsquared)})\r\n    removeSamples <- shiny::eventReactive(input$go, {as.character(input$removeSamples)})\r\n    Samples_Concentration <- reactiveVal() # Create a reactive value to store deconvolution object into Samples_Concentration() to allow other to access after observeEvent.\r\n\r\n\r\n    #Render raw table\r\n    output$table_Skyline_output <- DT::renderDT({\r\n        DT::datatable(Skyline_output(),\r\n                      options = list(\r\n                          paging = TRUE,\r\n                          pageLength = 50\r\n                      )\r\n        )\r\n    })\r\n\r\n\r\n    # Render reactive summary statistics and plots of raw input BEFORE quantification\r\n    # plots.R function\r\n    output$plot_Skyline_output <- plotly::renderPlotly({\r\n        plot_skyline_output(Skyline_output())\r\n\r\n    })\r\n\r\n\r\n\r\n    #----------------START: Deconvolution script------------------#\r\n\r\n    shiny::observeEvent(input$go, {\r\n\r\n        progress <- shiny::Progress$new()\r\n        on.exit(progress$close())\r\n\r\n        progress$set(message = \"WAIT! Processing data...\", value = 0)\r\n\r\n        # remove samples if selected by removeSamples input\r\n\r\n        if(!is.null(removeSamples()) && length(removeSamples()) > 0){\r\n            Skyline_output_filt <- Skyline_output() |>\r\n                dplyr::filter(!Replicate_Name %in% removeSamples())\r\n        } else{\r\n            Skyline_output_filt <- Skyline_output()\r\n        }\r\n\r\n\r\n\r\n        ##### PREPARE FOR DECONVOLUTION #######\r\n        # Prepare for deconvolution for standards\r\n        progress$set(value = 0.2, detail = \"Preparing standards data\")\r\n\r\n        # Prepare data frame for all standards to be used in deconvolution\r\n        if(input$standardTypes == \"Group Mixtures\"){\r\n\r\n            CPs_standards <- Skyline_output_filt |>\r\n                dplyr::filter(Sample_Type == \"Standard\",\r\n                              !Molecule_List %in% c(\"IS\", \"RS\", \"VS\"), # dont include IS, RS, VS\r\n                              Isotope_Label_Type == \"Quan\", # use only Quan ions\r\n                              Batch_Name != \"NA\") |>\r\n                dplyr::mutate(\r\n                    C_range = stringr::str_extract_all(Quantification_Group, \"\\\\d+\"), #extract all sequences of digits\r\n                    C_min = as.numeric(purrr::map_chr(C_range, ~.x[1])),\r\n                    C_max = as.numeric(purrr::map_chr(C_range, function(x) {if(length(x) > 1) {x[2]} else {x[1]}}))) |>\r\n                dplyr::select(-C_range) |>\r\n                dplyr::group_by(Batch_Name, Sample_Type, Molecule, Molecule_List, C_number, Cl_number, PCA, Quantification_Group, C_min, C_max) |>\r\n                tidyr::nest() |>\r\n                dplyr::filter(C_number >= C_min & C_number <= C_max) |> # make sure C_number stays within the Quantification_Group chain length\r\n                dplyr::mutate(models = purrr::map(data, ~lm(Area ~ Analyte_Concentration, data = .x))) |> #this includes intercept, if omitting intercept: Area~Analyte_Concentration -1\r\n                dplyr::mutate(coef = purrr::map(models, coef)) |>\r\n                dplyr::mutate(RF = purrr::map_dbl(models, ~ coef(.x)[\"Analyte_Concentration\"]))|> #get the slope which will be the RF\r\n                dplyr::mutate(intercept = purrr::map(coef, purrr::pluck(\"(Intercept)\"))) |>\r\n                dplyr::mutate(rsquared = purrr::map(models, summary)) |> #first create a data frame list with the model\r\n                dplyr::mutate(rsquared = purrr::map(rsquared, purrr::pluck(\"r.squared\"))) |> # then pluck only the r.squared value\r\n                dplyr::select(-coef) |>  # remove coef variable since it has already been plucked\r\n                tidyr::unnest(c(RF, intercept, rsquared)) |>  #removing the list type for these variables\r\n                dplyr::mutate(RF = if_else(RF < 0, 0, RF)) |> # replace negative RF with 0\r\n                dplyr::mutate(rsquared = ifelse(is.nan(rsquared), 0, rsquared)) |>\r\n                dplyr::mutate(RF = if_else(rsquared < removeRsquared(), 0, RF)) |> #replace RF with 0 if rsquared is below removeRsquared()\r\n                dplyr::ungroup() |>\r\n                dplyr::group_by(Batch_Name) |> #grouping by the standards\r\n                dplyr::mutate(Sum_RF_group = sum(RF, na.rm = TRUE)) |> #the sum RF per standard\r\n                dplyr::ungroup()\r\n\r\n\r\n            # Prepare for deconvolution of samples\r\n            progress$set(value = 0.6, detail = \"Preparing sample data\")\r\n\r\n\r\n            CPs_samples <- Skyline_output_filt |>\r\n                dplyr::filter(\r\n                    #Sample_Type == \"Unknown\",\r\n                    Sample_Type %in% c(\"Unknown\", \"Blank\"), #include both unknown and blank\r\n                    !Molecule_List %in% c(\"IS\", \"RS\", \"VS\"), # remove IS, RS, VS\r\n                    Isotope_Label_Type == \"Quan\") |>\r\n                dplyr::group_by(Replicate_Name) |>  # Group by Replicate Name\r\n                dplyr::mutate(Relative_Area = Area / sum(Area, na.rm = TRUE)) |> #Relative area\r\n                dplyr::ungroup() |>\r\n                dplyr::select(-Mass_Error_PPM, -Isotope_Label_Type, -Chromatogram_Precursor_MZ, -Analyte_Concentration, -Batch_Name) |>\r\n                dplyr::mutate(dplyr::across(Relative_Area, ~replace(., is.nan(.), 0)))  # Replace NaN with zero\r\n\r\n\r\n            CPs_samples_input <- CPs_samples |>\r\n                dplyr::select(Molecule, Replicate_Name, Relative_Area) |>\r\n                tidyr::pivot_wider(names_from = \"Replicate_Name\", values_from = \"Relative_Area\")\r\n\r\n\r\n\r\n            # Ensure combined_sample is correctly defined with nested data frames prior to deconvolution\r\n            combined_sample <- CPs_samples  |>\r\n                dplyr::group_by(Replicate_Name, Sample_Type) |>\r\n                tidyr::nest() |>\r\n                dplyr::ungroup()\r\n\r\n\r\n            ###### Plot calibration curves ######\r\n            # plots.R function\r\n            output$CalibrationCurves <- plotly::renderPlotly({\r\n                plot_calibration_curves(CPs_standards, quantUnit())\r\n            })\r\n\r\n            ###### Plot CalibrationRemoved ######\r\n            output$CalibrationRemoved <- DT::renderDT({\r\n                CPs_standards |>\r\n                    dplyr::filter(RF <= 0) |>\r\n                    dplyr::mutate(coef = purrr::map(models, coef)) |>\r\n                    dplyr::mutate(RF = purrr::map_dbl(models, ~ coef(.x)[\"Analyte_Concentration\"]))|> #get the slope which will be the RF\r\n                    dplyr::mutate(intercept = purrr::map(coef, purrr::pluck(\"(Intercept)\"))) |>\r\n                    dplyr::select(Batch_Name, Molecule, Quantification_Group,RF, intercept,  rsquared) |>\r\n                    tidyr::unnest(c(RF, intercept)) |>\r\n                    mutate(across(where(is.numeric), ~ signif(.x, digits = 4))) |>\r\n                    DT::datatable(options = list(pageLength = 40))\r\n            })\r\n\r\n\r\n            ###### Plot Quan/Qual ratios ######\r\n            #CPquant_plots.R function\r\n            output$RatioQuantToQual <- plotly::renderPlotly({\r\n                plot_quanqualratio(Skyline_output_filt)\r\n            })\r\n\r\n            ##### Plot MeasVSTheor ratios ######\r\n            #CPquant_plots.R function\r\n            output$MeasVSTheor <- plotly::renderPlotly({\r\n                plot_meas_vs_theor_ratio(Skyline_output_filt)\r\n            })\r\n\r\n\r\n            #### DECONVOLUTION ####\r\n\r\n            progress$set(value = 0.8, detail = \"Performing deconvolution\")\r\n\r\n\r\n            CPs_standards_input <- CPs_standards |>\r\n                dplyr::select(Molecule, Batch_Name, RF) |>\r\n                tidyr::pivot_wider(names_from = Batch_Name, values_from = \"RF\") |>\r\n                dplyr::mutate(across(everything(), ~ tidyr::replace_na(., 0)))\r\n\r\n\r\n            CPs_standards_sum_RF <- CPs_standards |>\r\n                dplyr::select(Batch_Name, Sum_RF_group) |>\r\n                dplyr::distinct() |>\r\n                dplyr::ungroup() |>\r\n                tidyr::pivot_wider(names_from = Batch_Name, values_from = \"Sum_RF_group\") |>\r\n                dplyr::mutate(across(everything(), ~ tidyr::replace_na(., 0)))\r\n\r\n\r\n            # First populate combined_standard with CPs_standards_input\r\n            combined_standard <- CPs_standards_input  |>\r\n                tibble::column_to_rownames(var = \"Molecule\") |>\r\n                as.matrix()\r\n\r\n\r\n\r\n            # This performs deconvolution on all mixtures together\r\n            deconvolution <- combined_sample |>\r\n                #perform_deconvolution on only Relative_Area in the nested data frame\r\n                dplyr::mutate(result = purrr::map(data, ~ perform_deconvolution(dplyr::select(.x, Relative_Area), combined_standard, CPs_standards_sum_RF))) |>\r\n                dplyr::mutate(sum_Area = purrr::map_dbl(data, ~sum(.x$Area))) |>\r\n                dplyr::mutate(sum_deconv_RF = as.numeric(purrr::map(result, purrr::pluck(\"sum_deconv_RF\")))) |>\r\n                dplyr::mutate(Concentration = sum_Area/sum_deconv_RF) |>\r\n                dplyr::mutate(Unit = quantUnit()) |>\r\n                dplyr::mutate(deconv_coef = purrr::map(result, ~as_tibble(list(deconv_coef = .x$deconv_coef, Batch_Name = names(.x$deconv_coef))))) |>\r\n                dplyr::mutate(deconv_rsquared = as.numeric(purrr::map(result, purrr::pluck(\"deconv_rsquared\")))) |>\r\n                dplyr::mutate(deconv_resolved = purrr::map(result, ~tibble::as_tibble(list(deconv_resolved = .x$deconv_resolved, Molecule = rownames(.x$deconv_resolved))))) |>\r\n                dplyr::select(-result)\r\n\r\n\r\n\r\n            #### Calculate the concentration ####\r\n\r\n            progress$set(value = 0.9, detail = \"Calculating final results\")\r\n\r\n\r\n\r\n            # Store Samples_Concentration in the reactive value\r\n            Samples_Concentration(deconvolution)\r\n\r\n        }\r\n\r\n        progress$set(value = 1, detail = \"Complete\")\r\n\r\n\r\n        ### END: Deconvolution script\r\n\r\n\r\n        # download results from deconvolution to different excel sheets\r\n        output$downloadResults <- shiny::downloadHandler(\r\n            filename = function() {\r\n                paste(\"CPquant_Results_\", Sys.Date(), \".xlsx\", sep = \"\")\r\n            },\r\n            content = function(file) {\r\n                # Create a new workbook\r\n                wb <- openxlsx::createWorkbook()\r\n\r\n                # Add worksheets\r\n                openxlsx::addWorksheet(wb, \"Quantification\")\r\n                openxlsx::addWorksheet(wb, \"StandardsContribution\")\r\n                openxlsx::addWorksheet(wb, \"HomologueDistribution\")\r\n\r\n                # Write data to worksheets\r\n                openxlsx::writeData(wb, \"Quantification\",\r\n                                    deconvolution |>\r\n                                        dplyr::select(Replicate_Name, Sample_Type, Concentration, Unit, deconv_rsquared) |>\r\n                                        dplyr::mutate(deconv_rsquared = round(deconv_rsquared, 3)))\r\n                openxlsx::writeData(wb, \"StandardsContribution\",\r\n                                    deconvolution |>\r\n                                        tidyr::unnest(deconv_coef) |>\r\n                                        tidyr::unnest_longer(c(deconv_coef, Batch_Name)) |>\r\n                                        dplyr::select(Replicate_Name, Batch_Name, deconv_coef) |>\r\n                                        dplyr::mutate(deconv_coef = deconv_coef * 100) |>\r\n                                        tidyr::pivot_wider(names_from = Batch_Name, values_from = deconv_coef))\r\n                openxlsx::writeData(wb, \"HomologueDistribution\",\r\n                                    test <- deconvolution |>\r\n                                        dplyr::mutate(data = purrr::map2(data, deconv_resolved, ~dplyr::inner_join(.x, .y, by = \"Molecule\"))) |>\r\n                                        dplyr::mutate(data = purrr::map(data, ~ .x |> dplyr::mutate(resolved_distribution = deconv_resolved / sum(deconv_resolved)))) |>\r\n                                        dplyr::select(-deconv_resolved) |>\r\n                                        tidyr::unnest(data) |>\r\n                                        dplyr::mutate(Deconvoluted_Distribution = as.numeric(resolved_distribution)) |>\r\n                                        dplyr::rename(Relative_Distribution = Relative_Area) |>\r\n                                        dplyr::mutate(Molecule_Concentration = Deconvoluted_Distribution * Concentration) |>\r\n                                        dplyr::select(Replicate_Name, Sample_Type, Molecule_List, Molecule, C_homologue, Cl_homologue, PCA,\r\n                                                      Relative_Distribution, Deconvoluted_Distribution, Molecule_Concentration, Unit)\r\n                )\r\n\r\n\r\n                # Save workbook\r\n                openxlsx::saveWorkbook(wb, file)\r\n            }\r\n        )\r\n\r\n\r\n        # Render table\r\n        output$quantTable <- DT::renderDT({\r\n            deconvolution |>\r\n                dplyr::select(Replicate_Name, Sample_Type, Concentration, Unit, deconv_rsquared) |> #select to make compact df for pivot_wider\r\n                dplyr::mutate(deconv_rsquared = round(deconv_rsquared, 3)) |>\r\n                DT::datatable(\r\n                    filter = \"top\", extensions = c(\"Buttons\", \"Scroller\"),\r\n                    options = list(scrollY = 650,\r\n                                   scrollX = 500,\r\n                                   deferRender = TRUE,\r\n                                   scroller = TRUE,\r\n                                   buttons = list(list(extend = \"excel\", filename = \"Samples_concentration\", title = NULL,\r\n                                                       exportOptions = list(\r\n                                                           modifier = list(page = \"all\")\r\n                                                       )),\r\n                                                  list(extend = \"csv\", filename = \"Samples_concentration\", title = NULL,\r\n                                                       exportOptions = list(\r\n                                                           modifier = list(page = \"all\")\r\n                                                       )),\r\n                                                  list(extend = \"colvis\", targets = 0, visible = FALSE)),\r\n                                   dom = \"lBfrtip\",\r\n                                   fixedColumns = TRUE),\r\n                    rownames = FALSE)\r\n\r\n        })\r\n\r\n        # render sampleContributionPlot\r\n        output$sampleContributionPlot <- renderPlotly({\r\n            plot_sample_contribution(deconvolution)})\r\n\r\n\r\n\r\n        ###########################################################QA/QC#######################################################\r\n\r\n        QAQC <- deconvolution |>\r\n            dplyr::select(Replicate_Name, Sample_Type, deconv_rsquared) |>\r\n            dplyr::mutate(deconv_rsquared = round(deconv_rsquared, 3))\r\n\r\n        if(input$calculateRecovery == \"Yes\") {\r\n            # Recovery calculations\r\n            recovery_data <- Skyline_output_filt |>\r\n                dplyr::filter(Isotope_Label_Type == \"Quan\",\r\n                              Molecule_List %in% c(\"IS\", \"RS\"))\r\n\r\n\r\n            RECOVERY <- recovery_data |>  # Calculate recovery\r\n                tidyr::pivot_wider(\r\n                    id_cols = c(Replicate_Name, Sample_Type),\r\n                    names_from = Molecule_List,\r\n                    values_from = Area\r\n                ) |>\r\n                dplyr::mutate(across(c(IS, RS), ~replace_na(.x, 0)))\r\n\r\n            # Calculate QC ratio\r\n            qc_ratio <- RECOVERY |>\r\n                dplyr::filter(Sample_Type == \"Quality Control\") |>\r\n                dplyr::mutate(RatioStd = IS / RS) |>\r\n                dplyr::summarize(AverageRatio = mean(RatioStd, na.rm = TRUE))\r\n\r\n            # Calculate sample recovery\r\n            RECOVERY <- RECOVERY |>\r\n                dplyr::filter(Sample_Type %in% c(\"Unknown\", \"Blank\")) |>\r\n                dplyr::mutate(\r\n                    RatioSample = IS / RS,\r\n                    Recovery = RatioSample / as.numeric(qc_ratio$AverageRatio),\r\n                    RecoveryPercentage = round(Recovery * 100, 0)\r\n                ) |>\r\n                dplyr::select(Replicate_Name, Sample_Type, RecoveryPercentage)\r\n\r\n            QAQC <- QAQC |>\r\n                dplyr::left_join(RECOVERY, by = c(\"Replicate_Name\", \"Sample_Type\"))\r\n        }\r\n\r\n        # Render recovery table\r\n        output$table_recovery <- DT::renderDT({\r\n            DT::datatable(QAQC,\r\n                          filter = \"top\",\r\n                          extensions = c(\"Buttons\", \"Scroller\"),\r\n                          options = list(\r\n                              scrollY = 650,\r\n                              scrollX = 500,\r\n                              deferRender = TRUE,\r\n                              scroller = TRUE,\r\n                              buttons = list(\r\n                                  list(extend = \"excel\",\r\n                                       filename = \"Samples_recovery\",\r\n                                       title = NULL,\r\n                                       exportOptions = list(modifier = list(page = \"all\"))),\r\n                                  list(extend = \"csv\",\r\n                                       filename = \"Samples_recovery\",\r\n                                       title = NULL,\r\n                                       exportOptions = list(modifier = list(page = \"all\"))),\r\n                                  list(extend = \"colvis\",\r\n                                       targets = 0,\r\n                                       visible = FALSE)\r\n                              ),\r\n                              dom = \"lBfrtip\",\r\n                              fixedColumns = TRUE\r\n                          ),\r\n                          rownames = FALSE)\r\n        })\r\n\r\n\r\n\r\n        if(input$calculateMDL == \"Yes\") {\r\n            #MDL calculations (need to take into account if blank subtraction affect or not)\r\n            if (input$blankSubtraction == \"No\"){\r\n\r\n                MDL_data <- deconvolution |>\r\n                    dplyr::filter(Sample_Type == \"Blank\") |>\r\n                    dplyr::summarize(\r\n                        MDL_sumPCA = mean(Concentration) + 3 * sd(Concentration, na.rm = TRUE),\r\n                        number_of_blanks = dplyr::n_distinct(Replicate_Name)\r\n                    )\r\n            } else if (input$blankSubtraction == \"Yes, by avg area of blanks\"){\r\n                MDL_data <- deconvolution |>\r\n                    dplyr::filter(Sample_Type == \"Blank\") |>\r\n                    dplyr::summarize(\r\n                        MDL_sumPCA = 3 * sd(Concentration, na.rm = TRUE),\r\n                        number_of_blanks = dplyr::n_distinct(Replicate_Name)\r\n                    )\r\n\r\n            }\r\n        }\r\n\r\n\r\n\r\n        # Render MDL table\r\n        output$table_MDL <- DT::renderDT({\r\n            if (exists(\"MDL_data\")) {\r\n                DT::datatable(MDL_data,\r\n                              options = list(\r\n                                  pageLength = 10,\r\n                                  dom = 't'\r\n                              ),\r\n                              rownames = FALSE)\r\n            } else {\r\n                NULL\r\n            }\r\n        })\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n    })\r\n\r\n\r\n\r\n    output$sampleSelectionUIOverlay <- renderUI({\r\n        req(Samples_Concentration())\r\n\r\n        # Get unique sample names\r\n        sample_names <- unique(Samples_Concentration()$Replicate_Name)\r\n\r\n        selectInput(\"selectedSamples\", \"Select samples to compare:\",\r\n                    choices = sample_names,\r\n                    multiple = TRUE,\r\n                    selected = NULL)\r\n    })\r\n\r\n    output$sampleSelectionUIComparisons <- renderUI({\r\n        req(Samples_Concentration())\r\n\r\n        # Get unique sample names\r\n        sample_names <- unique(Samples_Concentration()$Replicate_Name)\r\n\r\n        selectInput(\"selectedSamples\", \"Select samples to compare:\",\r\n                    choices = sample_names,\r\n                    multiple = TRUE,\r\n                    selected = NULL)\r\n    })\r\n\r\n    shiny::observeEvent(input$go2, {\r\n        req(Samples_Concentration())  # Make sure the data exists\r\n\r\n        withProgress(message = 'Generating plot...', value = 0, {\r\n\r\n            Sample_distribution <- Samples_Concentration() |>\r\n                dplyr::mutate(data = purrr::map2(data, deconv_resolved, ~dplyr::inner_join(.x, .y, by = \"Molecule\"))) |>\r\n                dplyr::mutate(data = purrr::map(data, ~ .x |> dplyr::mutate(resolved_distribution = deconv_resolved / sum(deconv_resolved)))) |>\r\n                dplyr::select(-deconv_resolved) |>\r\n                tidyr::unnest(data) |>\r\n                dplyr::mutate(resolved_distribution = as.numeric(resolved_distribution)) |>\r\n                dplyr::mutate(deconv_resolved = as.numeric(deconv_resolved)) |>\r\n                dplyr::mutate(Molecule_concentration = resolved_distribution * Concentration) #calculated conc of each molecule\r\n\r\n\r\n            incProgress(0.5)\r\n\r\n            if (input$plotHomologueGroups == \"All Samples Overview\") {\r\n                output$plotHomologuePatternStatic <- shiny::renderPlot({\r\n                    ggplot2::ggplot(Sample_distribution, aes(x = Molecule, y = Relative_Area, fill = C_homologue)) +\r\n                        ggplot2::geom_col() +\r\n                        ggplot2::facet_wrap(~Replicate_Name) +\r\n                        ggplot2::theme_minimal() +\r\n                        ggplot2::theme(axis.text.x = element_blank()) +\r\n                        ggplot2::labs(title = \"Relative Distribution (before deconvolution)\",\r\n                                      x = \"Homologue\",\r\n                                      y = \"Relative Distribution\")\r\n                })\r\n            } else if (input$plotHomologueGroups == \"Samples Overlay\") {\r\n                output$plotHomologuePatternOverlay <- plotly::renderPlotly({\r\n                    req(input$selectedSamples)\r\n                    req(Sample_distribution)\r\n\r\n                    # Filter for selected samples\r\n                    selected_samples <- Sample_distribution |>\r\n                        dplyr::filter(Replicate_Name %in% input$selectedSamples) |>\r\n                        dplyr::mutate(Molecule = factor(Molecule, levels = unique(Molecule[order(C_number, Cl_number)])))\r\n\r\n                    req(nrow(selected_samples) > 0)\r\n\r\n                    # Create a basic bar plot\r\n                    p <- plotly::plot_ly(data = selected_samples,\r\n                                         x = ~Molecule,\r\n                                         #y = ~resolved_distribution,\r\n                                         y = ~Relative_Area,\r\n                                         color = ~Replicate_Name,\r\n                                         type = \"bar\",\r\n                                         text = ~paste(\r\n                                             \"Sample:\", Replicate_Name,\r\n                                             \"<br>Homologue:\", Molecule,\r\n                                             \"<br>Distribution:\", round(Relative_Area, 3),\r\n                                             \"<br>C-atoms:\", C_homologue\r\n                                         ),\r\n                                         hoverinfo = \"text\"\r\n                    ) |>\r\n                        layout(\r\n                            #title = \"Sample Distribution Overlay\",\r\n                            xaxis = list(\r\n                                title = \"Homologue\",\r\n                                tickangle = 45\r\n                            ),\r\n                            yaxis = list(\r\n                                title = \"Distribution\"\r\n                            ),\r\n                            barmode = 'group',\r\n                            showlegend = TRUE,\r\n                            height = 600,\r\n                            margin = list(b = 100)  # Add more bottom margin for rotated labels\r\n                        )\r\n\r\n                    p\r\n                })\r\n            } else if (input$plotHomologueGroups == \"Samples Panels\") {\r\n                output$plotHomologuePatternComparisons <- plotly::renderPlotly({\r\n                    req(input$selectedSamples)\r\n                    #plots.R function\r\n                    plot_homologue_group_pattern_comparison(Sample_distribution, input$selectedSamples)\r\n                })\r\n            }\r\n\r\n\r\n\r\n            incProgress(1)\r\n        })\r\n    })\r\n\r\n\r\n\r\n    # Close the app when the session ends\r\n    if(!interactive()) {\r\n        session$onSessionEnded(function() {\r\n            stopApp()\r\n            q(\"no\")\r\n        })\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n# Run the application\r\nshinyApp(ui = ui, server = server)\r\n","type":"text"},{"name":"CPquant_Shinylive.Rproj","content":"Version: 1.0\r\nProjectId: f266ff83-7eb5-4930-806d-a2a7532cbeb0\r\n\r\nRestoreWorkspace: Default\r\nSaveWorkspace: Default\r\nAlwaysSaveHistory: Default\r\n\r\nEnableCodeIndexing: Yes\r\nUseSpacesForTab: Yes\r\nNumSpacesForTab: 4\r\nEncoding: UTF-8\r\n\r\nRnwWeave: Sweave\r\nLaTeX: pdfLaTeX\r\n\r\nAutoAppendNewline: Yes\r\nStripTrailingWhitespace: Yes\r\n","type":"text"},{"name":"README.md","content":"# CPquant_Shinylive\r\n  \r\nSome tutorial for deploying shinylive in github:  \r\nhttps://hbctraining.github.io/Training-modules/RShiny/lessons/shinylive.html  \r\nhttps://github.com/RamiKrispin/shinylive-r  \r\n  \r\n  \r\n  \r\nCreation of this serverless github pages was made using the following steps from the above tutorials:  \r\n  \r\nlibrary(shinylive)  \r\nlibrary(httpuv)  \r\nshinylive::export(appdir = \"..FULLPATH/CPquant_Shinylive/\", destdir = \"docs\")  \r\nwhere ..FULLPATH is the path in the local computer  \r\n\r\nhttpuv::runStaticServer(\"docs/\", port = 8008)\r\n","type":"text"},{"name":"instructions_CPquant.md","content":"\r\n# CPquant\r\n  \r\n  \r\n## Introduction    \r\nCPquant uses the deconvolution process proposed by Bogdal et al (Anal Chem, doi/10.1021/ac504444d) to estimate \r\nthe relative composition needed from different standards to match the measured homologue pattern of samples. \r\nThe underlying calculations are based on the CPCrawler R script by Perkons et al (Food Chem, doi/10.1016/j.foodchem.2019.125100).\r\nIn CPquant, the deconvolution is performed using the nnls package (https://cran.r-project.org/web/packages/nnls).  \r\n\r\n__The calculated concentrations are for those in the extract. The user can then export the results to excel and perform additional calculations to derive the concentrations in the samples__\r\n  \r\n  \r\n## Input file  \r\nThe input excel file should be exported from the Skyline results table. It should include the following column with the names:  \r\n`Replicate Name`: sample name  \r\n`Sample Type`: the following characters can be used, _Unknown_ (which is the sample to be quantified), _Blank_ (field blanks and procedural blanks are not distinguished), _Standard_ (standard used for quantification), _Quality Control_ (standard/sample used to determine the recovery).  \r\n`Molecule List`: compounds used internal standards are denoted `IS`, recovery standards as `RS`.  \r\n`Molecule`: PCA homologue group.  \r\n`Area`: integrated area from Skyline.  \r\n`Mass Error PPM`: might be exported from Skyline but currently not used by CPquant.  \r\n`Isotope Label Type`: Quan or Qual.  \r\n`Chromatogram Precursor M/Z`: might be exported from Skyline but currently not used by CPquant.  \r\n`Analyte Concentration`: For standards only. This is the standard concentrations/amounts. This column could be in concentration or weight/amount unit depending on the user input. It will affect the final quantification unit.  \r\n`Batch Name`: For standards only (leave blank for Unknown). This will determine which standards that belongs to a calibration series as well as which carbon chain groups to quantify with the standard.  \r\nThe naming of the Batch Name should be: CarbonGroups_StandardName. An underscore is a separator for the carbon chain group and standard name.  \r\nExample A: C10-C13_StandardA. This standard will then be used to quantify carbon chains C10, C12, C13 (the hyphen specify the range of carbon chains). This belongs to the StandardA which can be at different Analyte Concentration for the same calibration series.  \r\nExample B: C14_52%Cl. This standard will only quantify C14 carbon chains. It specifies 52% chlorine content (although this information is not needed for quantification).  \r\n  \r\n  \r\n## Quantification Inputs tab  \r\n__Import excel file from Skyline__: This is the excel file from the Report export function of Skyline.  \r\n__Concentration unit__: an optional input to indicate the concentration (or amount) unit of the Analyte Concentration in the Skyline report (e.g. ng/mL or ng).   \r\nAfter loading the excel, allow for the Area plot to show up before pressing the \"Proceed\" button, otherwise error will occur.  \r\n\r\nAfter loading the data, the user can choose the options:  \r\n__Subtraction by blank?__: If \"Yes, by avg area of blanks\", then the area for each Molecule will be subtracted with the average of all blank samples.  \r\n__Correct with RS area?__: If \"Yes\", then the area of each Molecule will the normalized to the recovery standard (RS) area for each sample.  \r\n__Calculate recovery?__: If \"Yes\", requires samples with the `Sample Type` designated as \"Quality Control\" that include the same concentrations of IS and RS.  \r\n__Calculate MDL?__: If \"Yes\", then calculates the method detection limits based on blank samples.  \r\nIf no blank subtraction then MDL = avg + 3 * standard deviation of blank samples.  \r\nIf blank subtraction then MDL = 3 * standard deviation of blank samples.  \r\n__Types of standards__: Currently only have option to use mixtures and single chain standards to perform deconvolution. More option can be added later for other quantification strategies.  \r\n  \r\n  \r\n__Remove samples from quantification?__: select samples to be removed before quantification process.  \r\n__Keep the the calibration curves above this rsquared__: remove calibration curves for every homologue groups in each standard below this R2 value. \r\nThis will remove all homologue groups that do not show linearity within the standard calibration concentrations, thus remove their contribution to the deconvolution. \r\nDefault is 0.8 but can be changed accordingly by the user.  \r\n  \r\n__Proceed__: pressing this button will quantify the samples based on the deconvolution process and the results will show up in the different tabs.  \r\n  \r\n\r\n### Quantification process  \r\nThe process starts by creating calibration curves for each carbon chain group for each standard mixture. \r\nThe Batch Name in the excel file determines which carbon chain group to be included for each standard mixture. A linear regression will be fitted and the slope is used as the response factor (RF).\r\nIf the R-squared of the goodnes of fit for a homologue group for a standard series (calibration curve) is below the user input threshold (modified in the first tab), then the homologue group in that standard is not considered for subsequent quantification.  \r\n\r\n\r\n\r\n## Input summary    \r\n### Choose tab  \r\nThe display might take some time before results show up here so be patient.  \r\n__Std Calibration Curves__: The calibration curves for different standards will be shown. Only those with rsquared above the initial cutoff will be shown.  \r\n__Removed from Calibration__: A table showing individual homologue groups from specific standards that are removed from the quantification process, due to negative RF or calibration curve R2 values below limit.   \r\n__Quan to Qual ratio__: Violin plots showing the ratio Quan/Qual area to detect outliers and thus help in assessing quality of data.  \r\n  \r\n  \r\n## Quantification summary  \r\n__Export all results to Excel__: export all results from the quantification to an excel file with different sheets.  \r\n__Quantification table__: this shows the quantification results directly in a table. The unit of the quantification depends on the design of concentration or weight amount specified by the user.  \r\n__Contributions from standards to deconvoluted homologue pattern__: this plot shows how much each standard contributes to the reconstructed homologue group pattern.  \r\n  \r\n  \r\n## Homologue Group Patterns  \r\n  \r\nPlots the relative distribution (relative area) of the samples.  \r\n__All Samples Overview__: gives a quick overview on homologue group patterns of all samples in a static plot.  \r\n__Samples Overlay__: overlays all selected samples in one plot.\r\n__Samples Panels__: plots one panel for each selected sample. Also compares the relative distribution of homologue groups of the sample with the reconstructed pattern \r\nby the deconvolution process (as scatter lines in the Deconvoluted Distribution legend group).  \r\n\r\nBE AWARE: CURRENTLY THE COLORS OF THE CARBON CHAIN GROUPS DOES NOT MATCH BETWEEN DIFFERENT SAMPLES  \r\n  \r\n  \r\n## QA/QC  \r\nVarious QA/QC results will show depending on the choices in the input tab. These include recovery and MDL calculations.  \r\n  \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n","type":"text"}]
